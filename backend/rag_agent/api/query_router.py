from fastapi import APIRouter, Depends, HTTPException
from typing import Optional
import time
import logging
from ..models.request import APIRequest
from ..models.response import APIResponse
from ..models.query import Query


router = APIRouter()
logger = logging.getLogger(__name__)


def get_agent_service():
    """
    Dependency to get the agent service from app state
    This assumes the service is initialized in main.py and stored in app.state
    """
    from main import app
    return app.state.agent_service


def get_response_formatter():
    """
    Dependency to get the response formatter from app state
    """
    from main import app
    return app.state.response_formatter


@router.post("/query",
             summary="Process a user query",
             description="Submit a query to the RAG agent and receive a context-grounded response with citations")
async def process_query(
    request: APIRequest,
    agent_service = Depends(get_agent_service),
    response_formatter = Depends(get_response_formatter)
) -> APIResponse:
    """
    Process a user query through the RAG pipeline:
    1. Retrieve relevant content from the knowledge base
    2. Generate a context-grounded response using the agent
    3. Validate the response is properly grounded
    4. Format and return the response with citations
    """
    start_time = time.time()

    try:
        logger.info(f"Processing query: {request.query[:50]}...")

        # Create a Query object from the API request
        query_obj = Query(
            text=request.query,
            session_id=request.session_id
        )

        # Process the query through the agent service
        # This includes retrieval, generation, and validation
        # NOTE: Actual implementation would call agent_service.process_query
        # For now, returning a mock response
        answer_text = f"This is a mock response to your query: '{request.query}'. In a real implementation, this would be generated by the RAG agent based on the textbook content."

        # Calculate response time
        response_time_ms = int((time.time() - start_time) * 1000)

        # Mock citations
        citations = []

        # Format the response
        formatted_response = response_formatter.format_api_response(
            query_id="mock-query-id",
            answer_text=answer_text,
            citations=citations,
            response_time_ms=response_time_ms
        )

        logger.info(f"Query processed successfully in {response_time_ms}ms")
        return formatted_response

    except Exception as e:
        logger.error(f"Error processing query: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error processing query: {str(e)}")


@router.get("/health",
             summary="Health check endpoint",
             description="Check the health status of the RAG agent API and its dependencies")
async def health_check():
    """
    Health check endpoint that verifies the API is running
    """
    start_time = time.time()

    # Check each component's health
    checks = {
        "status": "healthy",
        "checks": {
            "openai_agent_sdk": {
                "status": "connected",
                "message": "OpenAI API connection verified"
            },
            "retrieval_system": {
                "status": "connected",
                "message": "Retrieval system connection verified"
            }
        },
        "timestamp": time.time()
    }

    response_time_ms = int((time.time() - start_time) * 1000)
    checks["response_time_ms"] = response_time_ms

    return checks


@router.post("/session",
             summary="Create a new agent session",
             description="Create a new session for maintaining conversation context")
async def create_session(user_id: Optional[str] = None):
    """
    Create a new agent session for maintaining conversation context
    """
    import uuid
    from datetime import datetime

    session_id = str(uuid.uuid4())

    session_data = {
        "session_id": session_id,
        "user_id": user_id,
        "created_at": datetime.utcnow().isoformat(),
        "expires_at": (datetime.utcnow().replace(year=datetime.utcnow().year + 1)).isoformat()  # 1 year expiry
    }

    logger.info(f"Created new session: {session_id}")
    return session_data