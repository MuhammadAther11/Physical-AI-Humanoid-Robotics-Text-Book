from fastapi import APIRouter, HTTPException, Request
from typing import Dict, Any
import logging
from src.models.query import Query
from src.models.response import Response
from src.query_processing_service import QueryProcessingService
from src.config import Config
import time
from collections import defaultdict
from datetime import datetime, timedelta
import threading

logger = logging.getLogger(__name__)

# Rate limiting implementation
class RateLimiter:
    def __init__(self, max_requests: int = 10, window_size: int = 60):
        self.max_requests = max_requests
        self.window_size = window_size  # in seconds
        self.requests = defaultdict(list)  # userId -> list of timestamps
        self.lock = threading.Lock()

    def is_allowed(self, user_id: str = "anonymous") -> bool:
        """Check if a request from the given user is allowed under rate limits."""
        with self.lock:
            now = datetime.now()
            # Remove requests older than the window size
            self.requests[user_id] = [
                timestamp for timestamp in self.requests[user_id]
                if now - timestamp < timedelta(seconds=self.window_size)
            ]

            # Check if the user has exceeded the limit
            if len(self.requests[user_id]) >= self.max_requests:
                return False

            # Add the current request
            self.requests[user_id].append(now)
            return True

# Create rate limiter instance
rate_limiter = RateLimiter(max_requests=10, window_size=60)  # 10 requests per minute per user

# Create API router
router = APIRouter()

# Initialize the query processing service
query_service = QueryProcessingService()

@router.post("/query",
             summary="Submit a query to the RAG agent",
             description="Accepts user queries and returns responses generated by the RAG agent based on indexed content.")
async def query_endpoint(request: Request, query_data: Dict[str, Any]) -> Response:
    """
    Process a user query and return a response from the RAG agent.

    Args:
        request: The HTTP request object for logging and monitoring
        query_data: Dictionary containing the query information
                   Expected keys: 'query' (required), 'userId' (optional), 'context' (optional)

    Returns:
        Response object containing the agent's answer and sources
    """
    start_time = time.time()

    # Comprehensive request validation
    if not query_data:
        logger.warning("Empty query data received")
        raise HTTPException(status_code=400, detail="Query data is required")

    # Validate required fields
    if 'query' not in query_data or not query_data['query']:
        logger.warning("Missing or empty query field in request")
        raise HTTPException(status_code=400, detail="Query field is required and cannot be empty")

    # Validate field types
    if not isinstance(query_data['query'], str):
        logger.warning(f"Invalid query type: {type(query_data['query'])}")
        raise HTTPException(status_code=400, detail="Query field must be a string")

    if 'userId' in query_data and query_data['userId'] is not None and not isinstance(query_data['userId'], str):
        logger.warning(f"Invalid userId type: {type(query_data['userId'])}")
        raise HTTPException(status_code=400, detail="UserId field must be a string if provided")

    # Validate query length
    if len(query_data['query']) > Config.MAX_QUERY_LENGTH:
        logger.warning(f"Query exceeds maximum length: {len(query_data['query'])} > {Config.MAX_QUERY_LENGTH}")
        raise HTTPException(
            status_code=400,
            detail=f"Query exceeds maximum length of {Config.MAX_QUERY_LENGTH} characters"
        )

    # Rate limiting
    user_id = query_data.get('userId', 'anonymous')
    if not rate_limiter.is_allowed(user_id):
        logger.warning(f"Rate limit exceeded for user: {user_id}")
        raise HTTPException(
            status_code=429,
            detail=f"Rate limit exceeded. Maximum {rate_limiter.max_requests} requests per {rate_limiter.window_size} seconds."
        )

    try:
        # Validate and format the query
        formatted_query = query_service.validate_and_format_query(query_data)

        # Process the query through the service
        response = query_service.process_query(formatted_query)

        # Log successful query processing
        processing_time = time.time() - start_time
        logger.info(f"Successfully processed query {response.queryId} in {processing_time:.2f}s from user {user_id}")

        return response

    except ValueError as ve:
        processing_time = time.time() - start_time
        logger.warning(f"Invalid query format after validation: {str(ve)} (processed in {processing_time:.2f}s)")
        raise HTTPException(status_code=400, detail=f"Invalid query format: {str(ve)}")

    except Exception as e:
        processing_time = time.time() - start_time
        logger.error(f"Error processing query: {str(e)} (processed in {processing_time:.2f}s)")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")


@router.get("/health", 
            summary="Health check endpoint",
            description="Returns the health status of the API and its dependencies.")
async def health_check() -> Dict[str, Any]:
    """
    Health check endpoint to verify the service is running and dependencies are accessible.
    
    Returns:
        Dictionary with health status information
    """
    try:
        # Perform health check on the query processing service
        is_healthy = query_service.health_check()
        
        if is_healthy:
            return {
                "status": "healthy",
                "service": "RAG Query API",
                "timestamp": __import__('datetime').datetime.utcnow().isoformat(),
                "dependencies": {
                    "openai": "connected",
                    "qdrant": "connected"
                }
            }
        else:
            raise HTTPException(status_code=503, detail="Service dependencies are not healthy")
            
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        raise HTTPException(status_code=503, detail=f"Health check failed: {str(e)}")


# Additional endpoints can be added here as needed